---
title: C++学习3 表达式、语句和函数拾遗
tags: 梁子20163933
grammar_cjkRuby: true
---
> 本笔记并非对知识点的梳理，只是建立在回顾基础上上的重申和查缺补漏。

# 表达式
表达式由一个或多个运算对象构成，对表达式求值可得到结果。字面值（常量）和变量是最简单的对象。可以运用运算发将运算对象进行组合得到更为复杂的表达式。
## 运算符
包括一元运算符和二元运算符。
### 重载运算符
C++语言定义了内置类型和复合类型的运算符操作，但是对于用户自定义的类并没有定义运算符，因而用户可以对运算符进行自己的定义，这种定义得到的运算符被称为**重载运算符（overloaded operator）**。
### 左值和右值
C++的表达式为左值（lvalue）或右值（rvalue）中的一种。
在C++中，当一个对象被用作右值的时候，用的是对象的值（内容）；当一个对象被用作左值时，使用的是对象的身份（在内存中的位置）。
常见的运算符中用到左值的场景包括：
1. 赋值运算符。左侧和右侧的数值均为左值。
2. 取地址符（&），作用于一个左值对象，返回一个指向该左值对象的指针，这个指针是一个右值。
3. 内置解引用运算符、下标运算符、迭代器解引用运算符等等。
4. 内置类型和迭代器的递增递减运算符。
### 优先级和结合律
略
### 求值顺序
略
### 算术运算符
略
### 逻辑和关系运算符
略
### 成员访问运算符
点运算符和箭头运算符都可用于访问成员。点运算符用于获取类对象中的一个成员，箭头运算符与点运算符有关，即ptr->mem==(\*ptr).mem。
箭头运算符作用于一个指针类型的运算对象（确切地说，是一个指向类对象的指针），其结果是一个左值。
### 条件运算符
这个内容在C中是学习过的，在这里进行简单地复习。
所谓的条件运算符，就是将if else语句简化到单个表达式之中，格式如下：

**cond? expr1:expr2;**

其中cond是执行的条件判断，当其为真时，执行表达式1（expr1），否则执行表达式2（expr2）.
```c++
int grade=95;
string final_grade=(grade>=60)?"pass":"gua_ke";
```
#### 嵌套的条件预算符
正如if_else if语句一样，C++支持条件运算符嵌套使用。
```c++
final_grade=(grade<60)? "gua_ke"
										:(grade>=90) ? "high"
										:pass;
```
### 位运算符
这个在C语言单片机等中使用的较多，C++中使用并不频繁。略。
### sizeof运算符
sizeof运算符首先是一个运算符！不是一个函数！它可以返回一条表达式或者一个类型名字所占的字节数。
```c++
int data，*p;
sizeof (int);  //返回一个整形数据所占的字节数；
sizeof data;  //与上面一样
sizeof p;       //返回一个指向整形数据的指针所占的空间大小
sizeof *p;       //返回指针所指空间类型的内存大小
```
### 逗号运算符
表达式的结果是最右边的表达式的结果
### 类型转换
包括**隐式**类型转换和**显式**类型转换。
显式转换也称强制转换（**cast**）。
#### static_cast
任何具有明确定义的类型转换，只要不包括底层const，都可以使用static_cast.
```c++
int i,j;
double slope= static_cast<double>(i)/j;
```
#### const_cast
const_cast**只能**改变运算对象的底层const。
```c++
const char *p;
char *p=const_char<char>(p);
//可以用这种强制转换来去掉常变量的恒定属性。
```
#### reinterpret_cast
reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。
这个不介绍了，因为易出错。且不同机器的支持程度不同。
### 运算符优先级表
见147页。
# 语句
简单的部分、之前学过的部分全部省略。这里只介绍try语句块和异常处理部分。

异常指程序运行时的反常行为。典型的异常包括**失去数据库连接**和**遇到意外输入**等部分。当程序检测到一个无法处理的问题时，就需要用到异常处理。c++中的异常处理主要有两个方面：
1. **throw**表达式
2. **try**语句块。try语句块以关键字try开始，以一个或多个catch结束。try语句块中代码抛出的异常将会被魔域一个catch子句处理。这个整体被称为异常处理代码。
3. 一套**异常类**。

## throw表达式
在throw后面加一句表达式，来进行异常抛出。
## try语句块
try语句块的通用语法形式为：
try{
	program-statements(正常在运行的代码)
}	catch (exception-declaration这个是异常声明){
	handler-statement进行的进一步处理
}......
# 函数
## 形参和实参
和C中一样，实参是形参的初始值，实参的类型必须和形参对应。函数的形参列表可以为空，但是不能省略。
## 局部对象
C++中，名字有**作用域**，对象有**生命周期**。
**局部变量**：包括形参和位于函数体内的变量。
### 自动对象
只存在于块执行期间的对象。例如形参。
### 局部静态对象
对于需要将局部变量的生命周期贯穿到函数调用及之后的时间的变量，我们需要使用**static**类型来定义这些局部变量。
**局部静态对象**在程序执行第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间，即使对象所在的函数结束也不会对他有影响。
```c++
\\一个统计自己被调用了多少次的函数
size_t count_calls()
{
	static size_t ctr = 0;
	return ++ctr;
}
```
## 函数声明
函数的名字必须在使用之前声明。函数只能定义一次但是可以声明多次。函数的声明只需要描述函数的接口。
### 在头文件中进行函数声明
C++建议将变量、函数均在头文件进行声明，在源文件进行定义。
**含有函数声明的头文件应该被包含到定义函数的源文件中。且需要注意引入的时候是双引号而不是尖括号。**
## 分离式编译
即将不同的功能分散在不同的文件里，然后连接在一起进行编译。
## 参数传递
**如果形参式引用类型，那么该形参将会绑定到对应的实参上；否则，将实参的值拷贝给形参。** 前者被称为**引用传递**，后者被称为**值传递**。这也就是说，C++中的形参未必是对象，也有可能是引用。
### 传值函数
当进行值传递时，由于进行了拷贝操作，所以实参的数值不会被改变。
### 指针形参
指针形参在调用函数时可以改变被调用的实参对象的数值。C++中建议使用引用来代替指针。
### 传引用参数
正如所叙，在函数调用引用形参时会改变对应的实参的数值，在这里其作用是和指针相同的。

对于在函数内部功能上不需要对引用形参的数值进行改变的，一般用常量引用（const）来保证安全。
```c++
//比如比较两个string的长度
bool isShorter(const string &str1, const string &str2)
{
	return str1.size()<str2.size();
}
```
#### 使用形参返回多个值
一般，函数只能返回一个值。可以使用引用形参来达到返回多个值的目的。